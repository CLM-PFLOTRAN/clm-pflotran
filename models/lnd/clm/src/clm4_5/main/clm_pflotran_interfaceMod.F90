module clm_pflotran_interfaceMod

  !-----------------------------------------------------------------------
  !BOP
  !
  ! !MODULE: clm_pflotran_interfaceMod
  !
  ! !DESCRIPTION:
  ! Performs
  !
  ! !USES:

  !use clm_pflotran_interface_type
#ifdef CLM_PFLOTRAN
  use clm_pflotran_interface_data
  use pflotran_model_module
#endif

  ! !PUBLIC TYPES:
  implicit none


  save

  !type(clm_pflotran_interface_data_type),pointer,public   :: clm_pf_idata
#ifdef CLM_PFLOTRAN
  type(pflotran_model_type),pointer,public                :: pflotran_m
#endif
  !
  private    ! By default everything is private

  character(len=256), private :: pflotran_prefix = ''
  character(len=32), private :: restart_stamp = ''

  ! !PUBLIC MEMBER FUNCTIONS:
  public :: clm_pf_readnl

  ! wrappers around ifdef statements to maintain sane runtime behavior
  ! when pflotran is not available.
  public :: clm_pf_interface_init, &
       clm_pf_update_soil_moisture, &
       clm_pf_update_soil_temperature, &
       clm_pf_update_drainage, &
       clm_pf_step_th, &
       clm_pf_write_restart, clm_pf_set_restart_stamp, &
       clm_pf_vecget_gflux, clm_pf_vecrestore_gflux

#ifdef CLM_PFLOTRAN
  ! private work functions that truely require ifdef CLM_PFLOTRAN
  private :: interface_init_clm_pf, & ! Phase one initialization
       update_soil_moisture_clm_pf, &
       update_soil_temperature_clm_pf, &
       step_th_clm_pf, &
       write_restart_clm_pf, &
       vecget_gflux_clm_pf, vecrestore_gflux_clm_pf
#endif

contains

!-----------------------------------------------------------------------
!
! public interface functions allowing runtime behavior regardless of
! whether pflotran is compiled in.
!
!-----------------------------------------------------------------------

  !-----------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: clm_pf_readnl
  !
  ! !INTERFACE:
  subroutine clm_pf_readnl( NLFilename )
  !
  ! !DESCRIPTION:
  ! Read namelist for clm-pflotran interface
  !
  ! !USES:
    use clm_varctl    , only : iulog
    use spmdMod       , only : masterproc, mpicom
    use fileutils     , only : getavu, relavu, opnfil
    use clm_nlUtilsMod, only : find_nlgroup_name
    use shr_mpi_mod   , only : shr_mpi_bcast
    use abortutils    , only : endrun

    implicit none

  ! !ARGUMENTS:
    character(len=*), intent(IN) :: NLFilename ! Namelist filename
  ! !LOCAL VARIABLES:
    integer :: ierr                 ! error code
    integer :: unitn                ! unit for namelist file
    character(len=32) :: subname = 'clm_pf_readnl'  ! subroutine name
  !EOP
  !-----------------------------------------------------------------------
    namelist / clm_pflotran_inparm / pflotran_prefix

    ! ----------------------------------------------------------------------
    ! Read namelist from standard namelist file.
    ! ----------------------------------------------------------------------

    if ( masterproc )then

       unitn = getavu()
       write(iulog,*) 'Read in clm-pflotran namelist'
       call opnfil (NLFilename, unitn, 'F')
       call find_nlgroup_name(unitn, 'clm_pflotran_inparm', status=ierr)
       if (ierr == 0) then
          read(unitn, clm_pflotran_inparm, iostat=ierr)
          if (ierr /= 0) then
             call endrun(subname // ':: ERROR reading clm_pflotran_inparm namelist')
          end if
       end if
       call relavu( unitn )
       write(iulog, '(/, A)') " clm-pflotran namelist parameters :"
       write(iulog, '(A, " : ", A,/)') "   pflotran_prefix", trim(pflotran_prefix)
    end if

    ! Broadcast namelist variables read in
    call shr_mpi_bcast(pflotran_prefix, mpicom)
  end subroutine clm_pf_readnl



  !-----------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: clm_pf_set_restart_stamp
  !
  ! !INTERFACE:
  subroutine clm_pf_set_restart_stamp(clm_restart_filename)
  !
  ! !DESCRIPTION: Set the pflotran restart date stamp. Note we do NOT
  ! restart here, that gets handled by pflotran's internal
  ! initialization during interface_init_clm_pf()
  !
  ! !USES:
  ! !ARGUMENTS:
    character(len=256), intent(in) :: clm_restart_filename
  ! !LOCAL VARIABLES:
    integer :: name_length, start_pos, end_pos
    character(len=32) :: clm_stamp
  !EOP
  !-----------------------------------------------------------------------

    ! clm restart file name is of the form:
    !     ${CASE_NAME}.clm2.r.YYYY-MM-DD-SSSSS.nc
    ! we need to extract the: YYYY-MM-DD-SSSSS
    write(*, '("clm-pf : clm restart file name : ", A/)') trim(clm_restart_filename)
    name_length = len(trim(clm_restart_filename))
    start_pos = name_length - 18
    end_pos = name_length - 3
    clm_stamp = clm_restart_filename(start_pos : end_pos)
    write(*, '("clm-pf : clm date stamp : ", A/)') trim(clm_stamp)
    restart_stamp = clm_stamp

  end subroutine clm_pf_set_restart_stamp


  !-----------------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: pflotran_not_available
  !
  ! !INTERFACE:
  subroutine pflotran_not_available(subname)
  !
  ! !DESCRIPTION:
  ! Print an error message and abort.
  !
  ! !USES:
    use abortutils    , only : endrun
  ! !ARGUMENTS:
    implicit none
    character(len=*), intent(in) :: subname
  ! !LOCAL VARIABLES:
  !EOP
  !-----------------------------------------------------------------------
    call endrun(trim(subname) // ": ERROR: CLM-PFLOTRAN interface has not been compiled " // &
         "into this version of CLM.")
  end subroutine pflotran_not_available


!-----------------------------------------------------------------------
!
! public interface function wrappers
!
!-----------------------------------------------------------------------

  !-----------------------------------------------------------------------------
  subroutine clm_pf_interface_init()

    implicit none

    character(len=256) :: subname = "clm_pf_interface_init()"

#ifdef CLM_PFLOTRAN
    call interface_init_clm_pf()
#else
    call pflotran_not_available(subname)
#endif
  end subroutine clm_pf_interface_init


  !-----------------------------------------------------------------------------
  subroutine clm_pf_update_soil_moisture(cws, cps, lbc, ubc, &
       num_hydrologyc, filter_hydrologyc)

    use clmtype,              only : column_wstate_type, column_pstate_type
    use filterMod,            only : clumpfilter

    implicit none

    type(column_wstate_type), intent(inout) :: cws
    type(column_pstate_type), intent(inout) :: cps
    integer, intent(in) :: lbc, ubc                    ! column bounds
    integer, intent(in) :: num_hydrologyc              ! number of column soil points in column filter
    integer, intent(in) :: filter_hydrologyc(ubc-lbc+1)! column filter for soil points
    character(len=256) :: subname = "clm_pf_update_soil_moisture"

#ifdef CLM_PFLOTRAN
    call update_soil_moisture_clm_pf(cws, cps, lbc, ubc, num_hydrologyc, filter_hydrologyc)
#else
    call pflotran_not_available(subname)
#endif
  end subroutine clm_pf_update_soil_moisture


  !-----------------------------------------------------------------------------
  subroutine clm_pf_update_soil_temperature(lbl, ubl, lbc, ubc, &
       num_urbanl, filter_urbanl, &
       num_nolakec, filter_nolakec)

    use clmtype,              only : column_wstate_type, column_pstate_type
    use filterMod,            only : clumpfilter

    implicit none

    integer , intent(in)  :: lbc, ubc                    ! column bounds
    integer , intent(in)  :: num_nolakec                 ! number of column non-lake points in column filter
    integer , intent(in)  :: filter_nolakec(ubc-lbc+1)   ! column filter for non-lake points
    integer , intent(in)  :: lbl, ubl                    ! landunit-index bounds
    integer , intent(in)  :: num_urbanl                  ! number of urban landunits in clump
    integer , intent(in)  :: filter_urbanl(ubl-lbl+1)    ! urban landunit filter

    character(len=256) :: subname = "clm_pf_update_soil_temperature"

#ifdef CLM_PFLOTRAN
    call update_soil_temperature_clm_pf(lbl, ubl, lbc, ubc, &
       num_urbanl, filter_urbanl, &
       num_nolakec, filter_nolakec)
#else
    call pflotran_not_available(subname)
#endif
  end subroutine clm_pf_update_soil_temperature


  !-----------------------------------------------------------------------------
  subroutine clm_pf_update_drainage(lbc, ubc, &
       num_hydrologyc, filter_hydrologyc)

    integer, intent(in) :: lbc, ubc                    ! column bounds
    integer, intent(in) :: num_hydrologyc              ! number of column soil points in column filter
    integer, intent(in) :: filter_hydrologyc(ubc-lbc+1)! column filter for soil points
    character(len=256) :: subname = "clm_pf_update_drainage"

#ifdef CLM_PFLOTRAN
    call update_drainage_clm_pf(lbc, ubc, num_hydrologyc, filter_hydrologyc)
#else
    call pflotran_not_available(subname)
#endif

  end subroutine clm_pf_update_drainage

  !-----------------------------------------------------------------------------
  subroutine clm_pf_step_th(lbc, ubc, lbp, ubp, &
       num_nolakec, filter_nolakec, &
       num_hydrologyc, filter_hydrologyc, &
       num_snowc, filter_snowc, &
       num_nosnowc, filter_nosnowc)

    use clmtype,              only : r8, column_wstate_type, column_pstate_type
    use filterMod,            only : clumpfilter

    implicit none

    integer, intent(in) :: lbc, ubc                    ! column bounds
    integer, intent(in) :: lbp, ubp                    ! pft bounds
    integer, intent(in) :: num_nolakec                 ! number of column non-lake points in column filter
    integer, intent(in) :: filter_nolakec(ubc-lbc+1)   ! column filter for non-lake points
    integer, intent(in) :: num_hydrologyc              ! number of column soil points in column filter
    integer, intent(in) :: filter_hydrologyc(ubc-lbc+1)! column filter for soil points
    integer, intent(in)  :: num_snowc                  ! number of column snow points
    integer, intent(in)  :: filter_snowc(ubc-lbc+1)    ! column filter for snow points
    integer, intent(in)  :: num_nosnowc                ! number of column non-snow points
    integer, intent(in)  :: filter_nosnowc(ubc-lbc+1)  ! column filter for non-snow points

    character(len=256) :: subname = "clm_pf_step_th"

#ifdef CLM_PFLOTRAN
    call step_th_clm_pf(lbc, ubc, lbp, ubp, &
       num_nolakec, filter_nolakec, &
       num_hydrologyc, filter_hydrologyc, &
       num_snowc, filter_snowc, &
       num_nosnowc, filter_nosnowc)
#else
    call pflotran_not_available(subname)
#endif
  end subroutine clm_pf_step_th


  !-----------------------------------------------------------------------------
  subroutine clm_pf_vecget_gflux(gflux_clm_loc)

    use clmtype , only: r8

    implicit none
    real(r8), pointer :: gflux_clm_loc(:)

    character(len=256) :: subname = "clm_pf_vecget_gflux()"

#ifdef CLM_PFLOTRAN
    call vecget_gflux_clm_pf(gflux_clm_loc)
#else
    call pflotran_not_available(subname)
#endif
  end subroutine clm_pf_vecget_gflux



  !-----------------------------------------------------------------------------
  subroutine clm_pf_vecrestore_gflux(gflux_clm_loc)

    use clmtype    , only: r8

    implicit none
    real(r8), pointer :: gflux_clm_loc(:)

    character(len=256) :: subname = "clm_pf_vecrestore_gflux()"

#ifdef CLM_PFLOTRAN
    call vecrestore_gflux_clm_pf(gflux_clm_loc)
#else
    call pflotran_not_available(subname)
#endif
  end subroutine clm_pf_vecrestore_gflux



  !-----------------------------------------------------------------------------
  subroutine clm_pf_write_restart(date_stamp)

    implicit none
    character(len=*), intent(in) :: date_stamp

    character(len=32) :: subname = "clm_pf_write_restart"

#ifdef CLM_PFLOTRAN
    call write_restart_clm_pf(date_stamp)
#else
    call pflotran_not_available(subname)
#endif
  end subroutine clm_pf_write_restart



!-----------------------------------------------------------------------
!
! private work functions requiring pflotran
!
!-----------------------------------------------------------------------
#ifdef CLM_PFLOTRAN
  !-----------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: write_restart_clm_pf
  !
  ! !INTERFACE:
  subroutine write_restart_clm_pf(date_stamp)
  !
  ! !DESCRIPTION:
  ! Trigger a pflotran checkpoint file to be written
  !
  ! !USES:
  ! !ARGUMENTS:
    character(len=32), intent(in) :: date_stamp ! file name date stamp
  ! !LOCAL VARIABLES:


  !EOP
  !-----------------------------------------------------------------------

    call pflotranModelStepperCheckpoint(pflotran_m, date_stamp)

  end subroutine write_restart_clm_pf



  !-----------------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: vecget_gflux_clm_pf
  !
  ! !INTERFACE:
  subroutine vecget_gflux_clm_pf(gflux_clm_loc)
  !
  ! !DESCRIPTION:
  ! Wrapper around pflotran init
  !
  ! !USES:
    use clmtype    , only: r8
  ! !ARGUMENTS:
    implicit none

#include "finclude/petscsys.h"
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"

    real(r8), pointer :: gflux_clm_loc(:)
  ! !LOCAL VARIABLES:
    PetscErrorCode ierr
  !EOP
  !-----------------------------------------------------------------------
    call VecGetArrayF90(clm_pf_idata%gflux_clm, gflux_clm_loc, ierr); CHKERRQ(ierr)
  end subroutine vecget_gflux_clm_pf



  !-----------------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: vecrestore_gflux_clm_pf
  !
  ! !INTERFACE:
  subroutine vecrestore_gflux_clm_pf(gflux_clm_loc)
  !
  ! !DESCRIPTION:
  ! Wrapper around pflotran init
  !
  ! !USES:
    use clmtype    , only: r8
  ! !ARGUMENTS:
    implicit none

#include "finclude/petscsys.h"
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"

    real(r8), pointer :: gflux_clm_loc(:)
    PetscErrorCode ierr
  ! !LOCAL VARIABLES:
  !EOP
  !-----------------------------------------------------------------------

    call VecRestoreArrayF90(clm_pf_idata%gflux_clm, gflux_clm_loc, ierr); CHKERRQ(ierr)

  end subroutine vecrestore_gflux_clm_pf



  !-----------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: interface_init_clm_pf
  !
  ! !INTERFACE:
  subroutine interface_init_clm_pf()
    !
    ! !DESCRIPTION:
    ! initialize the pflotran iterface
    !
    ! !USES:
    use clmtype
    use clm_varctl      , only : iulog, fsurdat, scmlon, scmlat, single_column, &
         use_pflotran
    use decompMod       , only : get_proc_bounds, get_proc_global
    use clm_varpar      , only : nlevsoi, nlevgrnd
    use shr_kind_mod    , only: r8 => shr_kind_r8
    use decompMod       , only : ldecomp
    use domainMod       , only : ldomain
    
    use fileutils       , only : getfil
    use spmdMod         , only : mpicom, masterproc
    use organicFileMod  , only : organicrd
    use clm_varcon      , only : istice, istdlak, istwet, istice_mec,  &
         icol_roof, icol_sunwall, icol_shadewall, &
         icol_road_perv, icol_road_imperv, zisoi, zsoi, &
         istsoil, denice, denh2o
    use abortutils      , only : endrun

    use ncdio_pio

    ! pflotran
    use Option_module, only : printErrMsg
    use Simulation_Base_class, only : simulation_base_type
    use Subsurface_Simulation_class, only : subsurface_simulation_type
    use Surface_Simulation_class, only : surface_simulation_type
    use Surf_Subsurf_Simulation_class, only : surfsubsurface_simulation_type
    use Realization_class, only : realization_type
    use Surface_Realization_class, only : surface_realization_type

    !
    ! !ARGUMENTS:

    implicit none

#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"
#include "finclude/petscviewer.h"
#include "definitions.h"

    !
    ! !REVISION HISTORY:
    ! Created by Gautam Bisht
    !
    !EOP
    !
    ! LOCAL VARAIBLES:

    integer  :: begp, endp       ! per-proc beginning and ending pft indices
    integer  :: begc, endc       ! per-proc beginning and ending column indices
    integer  :: begl, endl       ! per-proc beginning and ending landunit indices
    integer  :: begg, endg       ! per-proc gridcell ending gridcell indices
    integer  :: nbeg, nend
    integer  :: numg             ! total number of gridcells across all processors
    integer  :: numl             ! total number of landunits across all processors
    integer  :: numc             ! total number of columns across all processors
    integer  :: nump             ! total number of pfts across all processors
    integer  :: n,g,l,c,p,lev,j  ! indices
    integer  :: gcount

    integer , pointer :: ctype(:)                   ! column type index
    logical ,pointer :: urbpoi(:)                   ! true => landunit is an urban point
    real(r8), pointer :: hksat(:,:)                 ! hydraulic conductivity at saturation (mm H2O /s) (nlevgrnd)
    real(r8), pointer :: sucsat(:,:)                ! minimum soil suction (mm) (nlevgrnd)
    real(r8), pointer :: watsat(:,:)                ! volumetric soil water at saturation (porosity) (nlevgrnd)
    integer , pointer :: cgridcell(:)               ! gridcell index of column
    integer , pointer :: clandunit(:)               ! landunit index of column
    real(r8), pointer :: wtgcell(:)                 ! weight (relative to gridcell)
    integer , pointer :: ltype(:)                   ! landunit type index
    real(r8), pointer :: h2osoi_vol(:,:)            ! volumetric soil water (0<=h2osoi_vol<=watsat) [m3/m3]
    real(r8), pointer :: h2osoi_liq(:,:)            ! liquid water (kg/m2)
    real(r8), pointer :: h2osoi_ice(:,:)  ! ice lens (kg/m2)
    real(r8), pointer :: t_soisno(:,:)              ! soil temperature (Kelvin)  (-nlevsno+1:nlevgrnd)
    real(r8), pointer :: topo(:)                    ! topography

    real(r8), pointer :: zwt(:)                     ! water table depth (m)

    real(r8), pointer :: hksat_x_loc(:)         ! hydraulic conductivity in x-dir at saturation (mm H2O /s) (nlevgrnd)
    real(r8), pointer :: hksat_y_loc(:)         ! hydraulic conductivity in y-dir at saturation (mm H2O /s) (nlevgrnd)
    real(r8), pointer :: hksat_z_loc(:)         ! hydraulic conductivity in z-dir at saturation (mm H2O /s) (nlevgrnd)
    real(r8), pointer :: sucsat_loc(:)          ! minimum soil suction (mm) (nlevgrnd)
    real(r8), pointer :: watsat_loc(:)          ! volumetric soil water at saturation (porosity) (nlevgrnd)
    real(r8), pointer :: bsw_loc(:)             ! Clapp and Hornberger "b" (nlevgrnd)
    real(r8), pointer :: zwt_2d_loc(:)          ! water table depth (m)
    real(r8), pointer :: topo_2d_loc(:)         ! Topogrpahy
    real(r8), pointer :: dz(:,:)                ! layer thickness (m)
    integer :: index
    
    real(r8), pointer :: latdeg(:)             ! latitude (radians)
    real(r8), pointer :: londeg(:)             ! longitude (radians)

    !
    ! From iniTimeConst.F90
    !
    type(file_desc_t)  :: ncid   ! netcdf id
    real(r8) :: clay,sand        ! temporaries

    real(r8),pointer :: arrayl(:)      ! generic global array
    integer ,pointer :: irrayg(:)      ! generic global array
    integer ,pointer :: soic2d(:)      ! read in - soil color
    real(r8),pointer :: sand3d(:,:)    ! read in - soil texture: percent sand
    real(r8),pointer :: clay3d(:,:)    ! read in - soil texture: percent clay
    real(r8),pointer :: organic3d(:,:) ! read in - organic matter: kg/m3
    real(r8),pointer :: gti(:)         ! read in - fmax
    integer  :: varid                  ! netCDF id's
    integer  :: ret

    real(r8) :: om_frac                ! organic matter fraction
    real(r8) :: om_watsat    = 0.9_r8  ! porosity of organic soil
    real(r8) :: om_hksat     = 0.1_r8  ! saturated hydraulic conductivity of organic soil [mm/s]
    real(r8) :: om_tkm       = 0.25_r8 ! thermal conductivity of organic soil (Farouki, 1986) [W/m/K]
    real(r8) :: om_sucsat    = 10.3_r8 ! saturated suction for organic matter (Letts, 2000)
    real(r8) :: om_csol      = 2.5_r8  ! heat capacity of peat soil *10^6 (J/K m3) (Farouki, 1986)
    real(r8) :: om_tkd       = 0.05_r8 ! thermal conductivity of dry organic soil (Farouki, 1981)
    real(r8) :: om_b         = 2.7_r8  ! Clapp Hornberger paramater for oragnic soil (Letts, 2000)
    real(r8) :: organic_max  = 130._r8 ! organic matter (kg/m3) where soil is assumed to act like peat
    real(r8) :: csol_bedrock = 2.0e6_r8 ! vol. heat capacity of granite/sandstone  J/(m3 K)(Shabbir, 2000)
    real(r8) :: pc           = 0.5_r8   ! percolation threshold
    real(r8) :: pcbeta       = 0.139_r8 ! percolation exponent
    real(r8) :: perc_frac               ! "percolating" fraction of organic soil
    real(r8) :: perc_norm               ! normalize to 1 when 100% organic soil
    real(r8) :: uncon_hksat             ! series conductivity of mineral/organic soil
    real(r8) :: uncon_frac              ! fraction of "unconnected" soil
    integer  :: start(3),count(3)       ! netcdf start/count arrays

    real(r8) :: watsat_tmp, bsw_tmp, sucsat_tmp, press_tmp
    real(r8) :: bd, tkm, bsw2_tmp,psisat_tmp
    real(r8) :: vwcsat_tmp, xksat, hksat_tmp

    integer  :: ier                                ! error status
    character(len=256) :: locfn                    ! local filEname
    character(len= 32) :: subname = 'clm_pf_interface_init' ! subroutine name
    integer :: mxsoil_color                        ! maximum number of soil color classes

    integer :: closelatidx,closelonidx
    real(r8):: closelat,closelon

    logical :: readvar
    logical , pointer :: lakpoi(:)      ! true => landunit is a lake point

    integer, pointer :: clm_cell_ids_nindex(:)
    integer, pointer :: clm_surf_cell_ids_nindex(:)
    integer :: clm_npts
    integer :: clm_surf_npts

    class(simulation_base_type), pointer :: simulation
    class(realization_type), pointer    :: realization
    class(surface_realization_type), pointer    :: surf_realization

    !PetscViewer :: viewer
    PetscScalar, pointer :: hksat_x_clm_loc(:) ! hydraulic conductivity in x-dir at saturation (mm H2O /s)
    PetscScalar, pointer :: hksat_y_clm_loc(:) ! hydraulic conductivity in y-dir at saturation (mm H2O /s)
    PetscScalar, pointer :: hksat_z_clm_loc(:) ! hydraulic conductivity in z-dir at saturation (mm H2O /s)
    PetscScalar, pointer :: watsat_clm_loc(:)  ! minimum soil suction (mm)
    PetscScalar, pointer :: sucsat_clm_loc(:)  ! volumetric soil water at saturation (porosity)
    PetscScalar, pointer :: bsw_clm_loc(:)     ! Clapp and Hornberger "b"
    PetscScalar, pointer :: press_clm_loc(:)   ! Pressure
    PetscScalar, pointer :: temp_clm_loc(:)    ! Temperature
    PetscScalar, pointer :: sat_clm_loc(:)     ! Saturation
    PetscErrorCode :: ierr

    ! Determine necessary indices

    call get_proc_bounds(begg, endg, begl, endl, begc, endc, begp, endp)
    call get_proc_global(numg, numl, numc, nump)

    ! Assign local pointers to derived subtypes components (landunit-level)
    ltype           => lun%itype
    urbpoi          => lun%urbpoi

    ! Assign local pointer to derived subtypes components (column-level)
    clandunit       => col%landunit
    cgridcell       => col%gridcell
    wtgcell         => col%wtgcell
    ctype           => col%itype
    hksat           => cps%hksat
    sucsat          => cps%sucsat
    watsat          => cps%watsat
    h2osoi_vol      => cws%h2osoi_vol
    h2osoi_liq      => cws%h2osoi_liq
    h2osoi_ice      => cws%h2osoi_ice
    t_soisno        => ces%t_soisno
    topo            => ldomain%topo
    zwt             => cws%zwt
    latdeg          => grc%latdeg
    londeg          => grc%londeg
    lakpoi          => lun%lakpoi
    dz              => cps%dz

    !------------------------------------------------------------------------
    allocate(pflotran_m)

    ! Create PFLOTRAN model
    pflotran_m => pflotranModelCreate(mpicom, pflotran_prefix)

    call pflotranModelSetupRestart(pflotran_m, restart_stamp)

    ! Initialize PETSc vector for data transfer between CLM and PFLOTRAN
    call CLMPFLOTRANIDataInit()

    select type (simulation => pflotran_m%simulation)
      class is (subsurface_simulation_type)
         realization => simulation%realization
         nullify(surf_realization)
      class is (surface_simulation_type)
         nullify(realization)
         surf_realization => simulation%surf_realization
      class is (surfsubsurface_simulation_type)
         realization => simulation%realization
         surf_realization => simulation%surf_realization
      class default
         pflotran_m%option%io_buffer = "clm-pflotran only works with surface and subsurface simulations."
         write(*, '(/A/)') pflotran_m%option%io_buffer
         call printErrMsg(pflotran_m%option)
    end select

    ! Compute number of cells in CLM domain.
    ! Assumption-1: One column per CLM grid cell.
    ! Assumption-2: nz = nlevsoi and nz /= nlevgrnd. Need to add a flag in input
    !               file to differenticate if PFLOTRAN grid is 'nlevsoi' or
    !               'nlevgrnd' deep.
    clm_npts = (endg-begg+1)*nlevsoi
    clm_surf_npts = (endg-begg+1)
    allocate(clm_cell_ids_nindex( 1:clm_npts))
    allocate(clm_surf_cell_ids_nindex(1:clm_surf_npts))

    ! Save cell IDs of CLM grid
    clm_npts = 0
    clm_surf_npts = 0
    do g = begg, endg
       do j = 1,nlevsoi
          clm_npts = clm_npts + 1
          clm_cell_ids_nindex(clm_npts) = (ldecomp%gdc2glo(g)-1)*nlevsoi + j - 1
       enddo
       clm_surf_npts=clm_surf_npts + 1
       clm_surf_cell_ids_nindex(clm_surf_npts)=(ldecomp%gdc2glo(g)-1)*nlevsoi
    enddo

    ! CLM: Subsurface domain (local and ghosted cells)
    clm_pf_idata%nlclm_3d = clm_npts
    clm_pf_idata%ngclm_3d = clm_npts

    ! CLM: Surface of subsurface domain (local and ghosted cells)
    clm_pf_idata%nlclm_surf_3d = (endg-begg+1)
    clm_pf_idata%ngclm_surf_3d = (endg-begg+1)
    ! For CLM: Same as surface of subsurface domain
    clm_pf_idata%nlclm_2d = clm_surf_npts
    clm_pf_idata%ngclm_2d = clm_surf_npts

    ! PFLOTRAN: Subsurface domain (local and ghosted cells)
    clm_pf_idata%nlpf_3d = realization%patch%grid%nlmax
    clm_pf_idata%ngpf_3d = realization%patch%grid%ngmax

    ! PFLOTRAN: Surface of subsurface domain (local and ghosted cells)
    if(pflotran_m%option%iflowmode == TH_MODE) then
      clm_pf_idata%nlpf_surf_3d = pflotranModelNSurfCells3DDomain(pflotran_m)
      clm_pf_idata%ngpf_surf_3d = pflotranModelNSurfCells3DDomain(pflotran_m)
    else
      clm_pf_idata%nlpf_surf_3d = 0
      clm_pf_idata%ngpf_surf_3d = 0
    endif
    
    ! PFLOTRAN: Surface domain (local and ghosted cells)
    if(associated(surf_realization) .and. pflotran_m%option%nsurfflowdof > 0) then
      clm_pf_idata%nlpf_2d = surf_realization%patch%grid%nlmax
      clm_pf_idata%ngpf_2d = surf_realization%patch%grid%ngmax
    else
      clm_pf_idata%nlpf_2d = 0
      clm_pf_idata%ngpf_2d = 0
    endif

    ! Allocate vectors for data transfer between CLM and PFLOTRAN.
    call CLMPFLOTRANIDataCreateVec(MPI_COMM_WORLD)

    ! Initialize maps for transferring data between CLM and PFLOTRAN.
    call pflotranModelInitMapping(pflotran_m, clm_cell_ids_nindex, &
                                  clm_npts, CLM2PF_FLUX_MAP_ID)
    call pflotranModelInitMapping(pflotran_m, clm_cell_ids_nindex, &
                                  clm_npts, CLM2PF_SOIL_MAP_ID)
    call pflotranModelInitMapping(pflotran_m, clm_cell_ids_nindex, &
                                  clm_npts, PF2CLM_FLUX_MAP_ID)

    if(pflotran_m%option%iflowmode==TH_MODE) then
      call pflotranModelInitMapping(pflotran_m, clm_surf_cell_ids_nindex, &
                                    clm_surf_npts, CLM2PF_GFLUX_MAP_ID)
    endif

#ifdef SURFACE_FLOW
    if(pflotran_m%option%nsurfflowdof > 0) then
      call pflotranModelInitMapping(pflotran_m, clm_surf_cell_ids_nindex, &
                                    clm_surf_npts, PF2CLM_SURF_MAP_ID)
      call pflotranModelInitMapping(pflotran_m, clm_surf_cell_ids_nindex, &
                                    clm_surf_npts, CLM2PF_RFLUX_MAP_ID)
    endif
#endif

    call VecGetArrayF90(clm_pf_idata%hksat_x_clm, hksat_x_clm_loc, ierr)
    call VecGetArrayF90(clm_pf_idata%hksat_y_clm, hksat_y_clm_loc, ierr)
    call VecGetArrayF90(clm_pf_idata%hksat_z_clm, hksat_z_clm_loc, ierr)
    call VecGetArrayF90(clm_pf_idata%sucsat_clm,  sucsat_clm_loc,  ierr)
    call VecGetArrayF90(clm_pf_idata%watsat_clm,  watsat_clm_loc,  ierr)
    call VecGetArrayF90(clm_pf_idata%bsw_clm,     bsw_clm_loc,     ierr)
    call VecGetArrayF90(clm_pf_idata%press_clm,   press_clm_loc,   ierr)

    write(iulog,*) '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
    write(iulog,*) '%%                                                     %%'
    write(iulog,*) '%%                                                     %%'
    write(iulog,*) '%%          Within clm_pf_interface_init               %%'
    write(iulog,*) '%%                                                     %%'
    write(iulog,*) '%%                                                     %%'
    write(iulog,*) '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'
    write(iulog,*) ' '

    allocate(sand3d(begg:endg,nlevsoi),clay3d(begg:endg,nlevsoi))
    allocate(organic3d(begg:endg,nlevsoi))

    ! --------------------------------------------------------------------
    ! Read soil color, sand and clay from surface dataset
    ! --------------------------------------------------------------------
    if (masterproc) then
       write(iulog,*) 'Attempting to read soil color, sand and clay boundary data .....'
    endif

    call getfil (fsurdat, locfn, 0)
    call ncd_pio_openfile(ncid, locfn, 0)

    ! Determine number of soil color classes - if number of soil color classes is not
    ! on input dataset set it to 8
    call ncd_io(ncid=ncid, varname='mxsoil_color', flag='read', data=mxsoil_color, &
                  readvar=readvar)
    if ( .not. readvar) mxsoil_color = 8

    call ncd_io(ncid=ncid, varname='PCT_SAND', flag='read', data=sand3d, dim1name=grlnd, readvar=readvar)
    if(.not. readvar) call endrun( trim(subname)//' ERROR: PCT_SAND NOT on surfadata file' )

    call ncd_io(ncid=ncid, varname='PCT_CLAY', flag='read', data=clay3d, dim1name=grlnd,readvar=readvar)
    if(.not. readvar) call endrun( trim(subname)//' ERROR: PCT_CLAY NOT on surfadata file' )

    ! --------------------------------------------------------------------
    ! If a organic matter dataset has been specified, read it
    ! --------------------------------------------------------------------

    call organicrd(organic3d)

    gcount = 0_r8 ! assumption that only 1 soil-column per grid cell
    do c = begc, endc

      ! Set gridcell and landunit indices
      g = cgridcell(c)
      l = clandunit(c)
      gcount = g - begg

      if (ltype(l)==istdlak .or. ltype(l)==istwet .or. ltype(l)==istice .or. ltype(l)==istice_mec) then
        write (iulog,*), 'WARNING: Land Unit type Lake/Wet/Ice/Ice_mec ... within the domain'
        write (iulog,*), 'CLM-CN -- PFLOTRAN does not support this land unit presently'
      else if (urbpoi(l) .and. (ctype(c) /= icol_road_perv) .and. (ctype(c) /= icol_road_imperv) )then
        ! Urban Roof, sunwall, shadewall properties set to special value
        write (iulog,*), 'WARNING: Land Unit type is Urban '
        write (iulog,*), 'CLM-CN -- PFLOTRAN does not support this land unit presently'
      else  ! soil columns of both urban and non-urban types

        do lev = 1,nlevgrnd

          ! duplicate clay and sand values from 10th soil layer
          if (lev .le. nlevsoi) then
            clay    = clay3d(g,lev)
              sand    = sand3d(g,lev)
            om_frac = (organic3d(g,lev)/organic_max)**2._r8
          else
            clay    = clay3d(g,nlevsoi)
            sand    = sand3d(g,nlevsoi)
            om_frac = 0._r8
          endif

          ! No organic matter for urban
          if (urbpoi(l)) then
            om_frac = 0._r8
          end if

          watsat_tmp = 0.489_r8 - 0.00126_r8*sand
          bsw_tmp    = 2.91 + 0.159*clay
          sucsat_tmp = 10._r8 * ( 10._r8**(1.88_r8-0.0131_r8*sand) )
          bd            = (1._r8-watsat_tmp)*2.7e3_r8
          watsat_tmp = (1._r8 - om_frac)*watsat_tmp + om_watsat*om_frac
          tkm           = (1._r8-om_frac)*(8.80_r8*sand+2.92_r8*clay)/(sand+clay)+om_tkm*om_frac ! W/(m K)
          bsw_tmp    = (1._r8-om_frac)*(2.91_r8 + 0.159_r8*clay) + om_frac*om_b
          bsw2_tmp   = -(3.10_r8 + 0.157_r8*clay - 0.003_r8*sand)
          psisat_tmp = -(exp((1.54_r8 - 0.0095_r8*sand + 0.0063_r8*(100.0_r8-sand-clay))*log(10.0_r8))*9.8e-5_r8)
          vwcsat_tmp = (50.5_r8 - 0.142_r8*sand - 0.037_r8*clay)/100.0_r8
          sucsat_tmp = (1._r8-om_frac)*sucsat_tmp + om_sucsat*om_frac
          xksat         = 0.0070556 *( 10.**(-0.884+0.0153*sand) ) ! mm/s

          ! perc_frac is zero unless perf_frac greater than percolation threshold
          if (om_frac > pc) then
            perc_norm=(1._r8 - pc)**(-pcbeta)
            perc_frac=perc_norm*(om_frac - pc)**pcbeta
          else
            perc_frac=0._r8
          endif

          !
          !                                ||
          !                                ||
          !                               \||/
          !
          !
          !            ******************************************
          !            *                                        *
          !            *                                        *
          !            *           ORGANIC PERCOLATING          *
          !            *               f_om*f_pre               *
          !            *                                        *
          ! ---\       ******************************************
          ! ---/       *                    *                   *
          !            *                    *                   *
          !            *                    *                   *
          !            *     ORGANIC        *       MINERAL     *
          !            *  NON-PERCOLATING   *                   *
          !            *                    *                   *
          !            *   f_om*(1-f_pre)   *       1-f_om      *
          !            *                    *                   *
          !            ******************************************
          !

          ! ---------------------------------------------------------------
          ! Hydraulic conductivity in Z-direction
          ! ---------------------------------------------------------------

          ! uncon_frac is fraction of mineral soil plus fraction of "nonpercolating" organic soil
          uncon_frac=(1._r8-om_frac)+(1._r8-perc_frac)*om_frac

          ! uncon_hksat is series addition of mineral/organic conductivites
          if (om_frac .lt. 1._r8) then
            uncon_hksat = uncon_frac/((1._r8-om_frac)/xksat &
                         + ((1._r8-perc_frac)*om_frac)/om_hksat)
          else
            uncon_hksat = 0._r8
          end if
          hksat_tmp  = uncon_frac*uncon_hksat + (perc_frac*om_frac)*om_hksat

          ! ---------------------------------------------------------------
          ! Hydraulic conductivity in X/Y-direction
          ! ---------------------------------------------------------------

          !
          if (om_frac .lt. 1._r8) then
            uncon_hksat = ( (1._r8 - om_frac)*xksat + &
                            (1._r8 - perc_frac)*om_frac*om_hksat )/uncon_frac
            hksat_tmp   = uncon_hksat*om_hksat/(om_frac*perc_frac*uncon_hksat &
                          + (1._r8 - om_frac*perc_frac)*om_hksat)
          else
            uncon_hksat = 0._r8
            hksat_tmp   = om_hksat
          end if

          press_tmp = 101325.0_r8 - 998.2_r8*9.81_r8*(zwt(g) - zsoi(lev))
          press_tmp = 101325.0_r8 - 998.2_r8*9.81_r8*(2.0_r8 - zsoi(lev))

          if (lev <= nlevsoi) then
            hksat_x_clm_loc(gcount*nlevsoi + lev ) = hksat_x_clm_loc(gcount*nlevsoi + lev ) + hksat_tmp*wtgcell(g)
            hksat_y_clm_loc(gcount*nlevsoi + lev ) = hksat_y_clm_loc(gcount*nlevsoi + lev ) + hksat_tmp*wtgcell(g)
            hksat_z_clm_loc(gcount*nlevsoi + lev ) = hksat_z_clm_loc(gcount*nlevsoi + lev ) + hksat(g,lev)*wtgcell(g)
            sucsat_clm_loc( gcount*nlevsoi + lev ) = sucsat_clm_loc( gcount*nlevsoi + lev ) + sucsat(g,lev)*wtgcell(g)
            watsat_clm_loc( gcount*nlevsoi + lev ) = watsat_clm_loc( gcount*nlevsoi + lev ) + watsat(g,lev)*wtgcell(g)
            bsw_clm_loc(    gcount*nlevsoi + lev ) = bsw_clm_loc(    gcount*nlevsoi + lev ) + bsw_tmp*wtgcell(g)
            press_clm_loc(  gcount*nlevsoi + lev ) = press_clm_loc(  gcount*nlevsoi + lev ) + press_tmp*wtgcell(g)

            if(pflotran_m%option%myrank.eq.-1) then
              write(*,'(I4,9F15.10)'), gcount*nlevsoi + lev, &
                                      sucsat_clm_loc( gcount*nlevsoi + lev ), &
                                      bsw_clm_loc(    gcount*nlevsoi + lev ), &
                                      watsat_clm_loc( gcount*nlevsoi + lev ), &
                                      hksat_x_clm_loc(gcount*nlevsoi + lev ), &
                                      hksat_y_clm_loc(gcount*nlevsoi + lev ), &
                                      hksat_z_clm_loc(gcount*nlevsoi + lev ), &
                                      998.2_r8*9.81_r8*(zwt(g) - zsoi(lev)), zwt(g), zsoi(lev)
              write(*,*),gcount*nlevsoi+lev, press_clm_loc(gcount*nlevsoi+lev)
            endif
          endif
        enddo 
      endif
    enddo ! do c = begc, endc

    call VecRestoreArrayF90(clm_pf_idata%hksat_x_clm, hksat_x_clm_loc, ierr)
    call VecRestoreArrayF90(clm_pf_idata%hksat_y_clm, hksat_y_clm_loc, ierr)
    call VecRestoreArrayF90(clm_pf_idata%hksat_z_clm, hksat_z_clm_loc, ierr)
    call VecRestoreArrayF90(clm_pf_idata%sucsat_clm,  sucsat_clm_loc,  ierr)
    call VecRestoreArrayF90(clm_pf_idata%watsat_clm,  watsat_clm_loc,  ierr)
    call VecRestoreArrayF90(clm_pf_idata%bsw_clm,     bsw_clm_loc,     ierr)
    call VecRestoreArrayF90(clm_pf_idata%press_clm,   press_clm_loc,   ierr)

    ! Set CLM soil properties onto PFLOTRAN grid
    call pflotranModelSetSoilProp(pflotran_m)
    !call pflotranModelSetICs(pflotran_m)

    ! Initialize PFLOTRAN states
    call pflotranModelStepperRunInit(pflotran_m)

    ! Get top surface area
    call pflotranModelGetTopFaceArea(pflotran_m)

    ! Get PFLOTRAN states
    call pflotranModelGetUpdatedStates(pflotran_m)

    ! Initialize soil temperature
    if(pflotran_m%option%iflowmode==TH_MODE) then
      call VecGetArrayF90(clm_pf_idata%temp_clm, temp_clm_loc, ierr)
      do c = begc,endc
        l = clandunit(c)
        if (.not. lakpoi(l)) then  !not lake
         g = cgridcell(c)
         gcount = g - begg
         do j = 1, nlevsoi
            t_soisno(c,j) = temp_clm_loc(gcount*nlevsoi+j)+273.15_r8
         enddo
         t_soisno(c,nlevsoi+1:nlevgrnd) = t_soisno(c,nlevsoi)
        endif
      enddo
      call VecRestoreArrayF90(clm_pf_idata%temp_clm, temp_clm_loc, ierr)
    endif

    ! Initialize soil moisture
    call VecGetArrayF90(clm_pf_idata%sat_clm, sat_clm_loc, ierr)
    call VecGetArrayF90(clm_pf_idata%watsat_clm, watsat_clm_loc, ierr)
    call get_proc_bounds(begg, endg, begl, endl, begc, endc, begp, endp)
    do c = begc,endc
      l = clandunit(c)
      if (ltype(l) == istsoil) then
        g = cgridcell(c)
        gcount = g - begg
        do j = 1, nlevsoi
          h2osoi_liq(c,j) = sat_clm_loc(gcount*nlevsoi+j)*dz(c,j)*1.e3_r8
          h2osoi_vol(c,j) = h2osoi_liq(c,j)/dz(c,j)/denh2o + &
                            h2osoi_ice(c,j)/dz(c,j)/denice
          h2osoi_vol(c,j) = min(h2osoi_vol(c,j),watsat(c,j))
        enddo
      endif
    enddo
    call VecGetArrayF90(clm_pf_idata%sat_clm, sat_clm_loc, ierr)
    call VecGetArrayF90(clm_pf_idata%watsat_clm, watsat_clm_loc, ierr)

    deallocate(sand3d,clay3d,organic3d)
  end subroutine interface_init_clm_pf


  !-----------------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: update_soil_moisture_clm_pf
  !
  ! !INTERFACE:
  subroutine update_soil_moisture_clm_pf(cws, cps, lbc, ubc, &
       num_hydrologyc, filter_hydrologyc)
  !
  ! !DESCRIPTION:
  ! 
  !
  ! !USES:
    use clmtype,              only : r8, col, column_wstate_type, column_pstate_type
    use clm_varctl          , only : iulog
    use decompMod           , only : get_proc_clumps, get_clump_bounds, get_proc_bounds
    use clm_time_manager    , only : get_nstep
    use clm_varcon,           only : denh2o, denice
    use clm_varpar,           only : nlevsoi
    use filterMod,            only : clumpfilter

  ! !ARGUMENTS:
    implicit none

#include "finclude/petscsys.h"
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"

    type(column_wstate_type), intent(inout) :: cws
    type(column_pstate_type), intent(inout) :: cps
    integer, intent(in) :: lbc, ubc                    ! column bounds
    integer, intent(in) :: num_hydrologyc              ! number of column soil points in column filter
    integer, intent(in) :: filter_hydrologyc(ubc-lbc+1)! column filter for soil points

  ! !LOCAL VARIABLES:
    integer  :: nstep                    ! time step number
    integer  :: nc, fc, c, fp, p, l, g, gcount   ! indices
    integer  :: nclumps                  ! number of clumps on this processor
    integer  :: begg, endg               ! clump beginning and ending gridcell indices
    integer  :: begl, endl               ! clump beginning and ending landunit indices
    integer  :: begc, endc               ! clump beginning and ending column indices
    integer  :: begp, endp               ! clump beginning and ending pft indices

    ! cps%dz(:,:) == layer thickness depth (m)
    ! cws%h2osoi_liq(:,:)  == liquid water (kg/m2)
    ! h2osoi_ice(:,:)  == ice lens (kg/m2)
    ! h2osoi_vol(:,:) == volumetric soil water (0<=h2osoi_vol<=watsat) [m3/m3]
    ! col%cgridcell(:) == column's gridcell
    PetscScalar, pointer :: sat_clm_loc(:) 
    PetscScalar, pointer :: watsat_clm_loc(:)
    PetscErrorCode :: ierr
    integer :: j
    real(r8):: tmp
  !EOP
  !-----------------------------------------------------------------------

  ! =======================================================================
  ! For NSTEP=0; update the soil moisture values that were initialized in
  !              PFLOTRAN. Variables modified
  !   h2osoi_liq [kg/m^2]  
  !   h2osoi_vol[m^3/m^3] (water + ice)
  ! =======================================================================

    nclumps = get_proc_clumps()
    nstep   = get_nstep()

    call VecGetArrayF90(clm_pf_idata%sat_clm, sat_clm_loc, ierr); CHKERRQ(ierr)
    call VecGetArrayF90(clm_pf_idata%watsat_clm, watsat_clm_loc, ierr); CHKERRQ(ierr)
    call get_proc_bounds(begg, endg, begl, endl, begc, endc, begp, endp)

    do fc = 1,num_hydrologyc
      c = filter_hydrologyc(fc)
      g = col%gridcell(c)
      gcount = g - begg
      do j = 1, nlevsoi
        cws%h2osoi_liq(c,j) = sat_clm_loc(gcount*nlevsoi + j) * cps%watsat(c,j) * cps%dz(c,j) * denh2o
        cws%h2osoi_vol(c,j) = cws%h2osoi_liq(c,j) / cps%dz(c,j) / denh2o + &
             cws%h2osoi_ice(c,j) / cps%dz(c,j) / denice
        cws%h2osoi_vol(c,j) = min(cws%h2osoi_vol(c,j), cps%watsat(c,j))
        !TODO(2013-07-02) update ice if pflotran is in TH mode.
      enddo
   enddo

    call VecRestoreArrayF90(clm_pf_idata%sat_clm, sat_clm_loc, ierr); CHKERRQ(ierr)
    call VecRestoreArrayF90(clm_pf_idata%watsat_clm, watsat_clm_loc, ierr); CHKERRQ(ierr)

    do fc = 1, num_hydrologyc
       c = filter_hydrologyc(fc)
      cws%qcharge(c) = 0.0_r8
    end do

  end subroutine update_soil_moisture_clm_pf



  !-----------------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: step_th_clm_pf
  !
  ! !INTERFACE:
  subroutine step_th_clm_pf(lbc, ubc, lbp, ubp, &
       num_nolakec, filter_nolakec, &
       num_hydrologyc, filter_hydrologyc, &
       num_snowc, filter_snowc, &
       num_nosnowc, filter_nosnowc)
  !
  ! !DESCRIPTION:
  ! 
  !
  ! !USES:
    use clmtype, only : r8, pft, col, pps, pwf, pwf_a, cps, cws, cwf

    use pflotran_model_module, only :pflotranModelUpdateFlowConds, &
         pflotranModelStepperRunTillPauseTime, &
         pflotranModelGetUpdatedStates

    use clm_pflotran_interface_data
    use clm_varctl                 , only : iulog
    use decompMod                  , only : get_proc_bounds, get_proc_global
    use clm_varpar                 , only : max_pft_per_col
    use clm_varpar      , only : nlevsoi
    use clm_time_manager, only : get_step_size, get_nstep, is_perpetual

  ! !ARGUMENTS:
    implicit none

#include "finclude/petscsys.h"
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"

    integer, intent(in) :: lbc, ubc                    ! column bounds
    integer, intent(in) :: lbp, ubp                    ! pft bounds
    integer, intent(in) :: num_nolakec                 ! number of column non-lake points in column filter
    integer, intent(in) :: filter_nolakec(ubc-lbc+1)   ! column filter for non-lake points
    integer, intent(in) :: num_hydrologyc              ! number of column soil points in column filter
    integer, intent(in) :: filter_hydrologyc(ubc-lbc+1)! column filter for soil points
    integer, intent(in)  :: num_snowc                  ! number of column snow points
    integer, intent(in)  :: filter_snowc(ubc-lbc+1)    ! column filter for snow points
    integer, intent(in)  :: num_nosnowc                ! number of column non-snow points
    integer, intent(in)  :: filter_nosnowc(ubc-lbc+1)  ! column filter for non-snow points

  ! !LOCAL VARIABLES:
    integer  :: c, fc, g, gcount, j, p   ! do loop indices
    integer  :: pftindex                        ! pft index
    integer  :: begp, endp                ! per-proc beginning and ending pft indices
    integer  :: begc, endc                ! per-proc beginning and ending column indices
    integer  :: begl, endl                ! per-proc beginning and ending landunit indices
    integer  :: begg, endg                ! per-proc gridcell ending gridcell indices
    integer  :: nbeg, nend
    integer  :: numg                      ! total number of gridcells across all processors
    integer  :: numl                      ! total number of landunits across all processors
    integer  :: numc                      ! total number of columns across all processors
    integer  :: nump                      ! total number of pfts across all processors
    real(r8) :: tmp
    real(r8) :: dtime                      ! land model time step (sec)
    integer  :: nstep                      ! time step number

    real(r8), pointer :: wtcol(:)             ! pft weight relative to column
    real(r8), pointer :: pwtcol(:)            ! weight relative to column for each pft
    real(r8), pointer :: pwtgcell(:)          ! weight relative to gridcell for each pft
    real(r8), pointer :: rootr_pft(:,:)       ! effective fraction of roots in each soil layer
    real(r8), pointer :: qflx_tran_veg_pft(:) ! vegetation transpiration (mm H2O/s) (+ = to atm)
    real(r8), pointer :: qflx_tran_veg_col(:) ! vegetation transpiration (mm H2O/s) (+ = to atm)
    real(r8), pointer :: qflx_evap_soi_pft(:) ! soil evaporation (mm H2O/s) (+ = to atm)
    integer , pointer :: pfti(:)              ! beginning pft index for each column
    !real(r8) :: den
    real(r8) :: temp(lbc:ubc)                 ! accumulator for rootr weighting
    real(r8), pointer :: rootr_col(:,:)       ! effective fraction of roots in each soil layer

    PetscScalar, pointer :: sat_clm_loc(:)    !
    PetscScalar, pointer :: qflx_clm_loc(:)   !
    PetscScalar, pointer :: area_clm_loc(:)   !
    PetscErrorCode :: ierr
    real(r8) :: area

  !EOP
  !-----------------------------------------------------------------------
    !den = 998.2_r8 ! [kg/m^3]
    !den = 1000._r8 ! [kg/m^3]

    qflx_tran_veg_col => pwf_a%qflx_tran_veg

    ! Assign local pointers to derived type members (pft-level)
    qflx_tran_veg_pft => pwf%qflx_tran_veg
    qflx_evap_soi_pft => pwf%qflx_evap_soi
    rootr_pft         => pps%rootr
    pwtgcell          => pft%wtgcell
    pwtcol            => pft%wtcol
    pfti              => col%pfti
    rootr_col         => cps%rootr_column
    wtcol             => pft%wtcol

    nstep = get_nstep()
    dtime = get_step_size()

    call VecGetArrayF90(clm_pf_idata%sat_clm, sat_clm_loc, ierr); CHKERRQ(ierr)
    call VecGetArrayF90(clm_pf_idata%qflx_clm, qflx_clm_loc, ierr); CHKERRQ(ierr)
    call VecGetArrayF90(clm_pf_idata%area_top_face_clm, area_clm_loc, ierr); CHKERRQ(ierr)

    ! Determine necessary indices
    call get_proc_bounds(begg, endg, begl, endl, begc, endc, begp, endp)
    call get_proc_global(numg, numl, numc, nump)

    ! Initialize to ZERO
    do g = begg, endg
      do j = 1,nlevsoi
        gcount = g - begg
        qflx_clm_loc(gcount*nlevsoi + j ) = 0.0_r8
      end do
    end do

    ! Compute the Infiltration - Evaporation at each grid-level
    ! qflx_infl [mm/sec],
    ! qflx_clm_loc [m^3/sec] (assuming top surf-area = 1 m^2)
    !
    ! [m^3/s] = [mm/s]/1000
    !

    gcount = 1_r8 ! assumption that only 1 soil-column per grid cell
    do c = begc, endc
     ! Set gridcell indices
     g = col%gridcell(c)
     gcount = g - begg
     j = 1
     area = area_clm_loc(gcount*nlevsoi+j)
     qflx_clm_loc(gcount*nlevsoi + j) = qflx_clm_loc(gcount*nlevsoi + j) + &
                                        cwf%qflx_infl(c)*col%wtgcell(c)*area
    enddo

    ! Compute the Transpiration sink at grid-level for each soil layer
    ! qflx_tran_veg_pft [mm/sec], while
    ! qflx_clm_loc      [kg/sec] (assuming top surf-area = 1 m^2)

    ! (i) Initialize root faction at column level to be zero
    do j = 1, nlevsoi
      do fc = 1, num_hydrologyc
        c = filter_hydrologyc(fc)
        rootr_col(c,j) = 0._r8
      end do
    end do

    temp(:) = 0._r8

    ! (ii) Compute the root fraction at column level
    do pftindex = 1,max_pft_per_col
      do j = 1,nlevsoi
        do fc = 1, num_hydrologyc
          c = filter_hydrologyc(fc)
          if (pftindex <= col%npfts(c)) then
            p = pfti(c) + pftindex - 1
            if (pwtgcell(p)>0._r8) then
              rootr_col(c,j) = rootr_col(c,j) + &
              rootr_pft(p,j) * qflx_tran_veg_pft(p) * pwtcol(p)
            end if
          end if
        end do
      end do


      do fc = 1, num_hydrologyc
        c = filter_hydrologyc(fc)
        if (pftindex <= col%npfts(c)) then
          p = pfti(c) + pftindex - 1
          if (pwtgcell(p)>0._r8) then
            temp(c) = temp(c) + qflx_tran_veg_pft(p) * pwtcol(p)
          end if
        end if
      end do
    end do

    ! (iii) Compute the Transpiration sink
    do j = 1, nlevsoi
      do fc = 1, num_hydrologyc
        c = filter_hydrologyc(fc)
        g = col%gridcell(c)
        gcount = g - begg
        if (temp(c) /= 0._r8) then
          rootr_col(c,j) = rootr_col(c,j)/temp(c)
          area = area_clm_loc(gcount*nlevsoi+j)
          qflx_clm_loc(gcount*nlevsoi + j ) = &
                              qflx_clm_loc(gcount*nlevsoi + j ) - &
                              qflx_tran_veg_col(c)*rootr_col(c,j)*area
        end if
      end do
    end do


    ! Set the 'new' saturation states; which PFLOTRAN will evolve.
    ! NOTE: The 'new' saturation states arise because of the phase
    !       change of water during the evolution of soil temperature
    !       states
    do j = 1, nlevsoi
      do fc = 1, num_nolakec
        c = filter_nolakec(fc)
        ! Set gridcell and landunit indices
        g = col%gridcell(c)
        !clm_pf_data%sat(g,j) = clm_pf_data%sat(g,j) + &
        !     h2osoi_liq(c,j)/dz(c,j)/denh2o/watsat(c,j) * col%wtgcell(c)
      end do
    end do

    call VecRestoreArrayF90(clm_pf_idata%sat_clm, sat_clm_loc, ierr); CHKERRQ(ierr)
    call VecRestoreArrayF90(clm_pf_idata%qflx_clm, qflx_clm_loc, ierr); CHKERRQ(ierr)
    call VecRestoreArrayF90(clm_pf_idata%area_top_face_clm, area_clm_loc, ierr); CHKERRQ(ierr)

    call pflotranModelUpdateFlowConds( pflotran_m )
    call pflotranModelStepperRunTillPauseTime( pflotran_m, (nstep+1.0d0)*dtime )
    call pflotranModelGetUpdatedStates( pflotran_m )

  end subroutine step_th_clm_pf

  !-----------------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: update_soil_temperature_clm_pf
  !
  ! !INTERFACE:
  subroutine update_soil_temperature_clm_pf(lbl, ubl, lbc, ubc, &
       num_urbanl, filter_urbanl, &
       num_nolakec, filter_nolakec)

  !
  ! !DESCRIPTION:
  ! 
  !
  ! !USES:
    use shr_kind_mod  , only : r8 => shr_kind_r8
    use clmtype
    use clm_time_manager  , only : get_step_size
    use clm_varctl    , only : iulog
    use clm_varpar    , only : nlevsno, nlevgrnd, nlevsoi 
    use decompMod    , only : get_proc_bounds, get_proc_global
    use decompMod                  , only : get_proc_bounds, get_proc_global
    use clm_varpar                 , only : max_pft_per_col

    use clm_pflotran_interface_data, only : clm_pf_idata

  ! !ARGUMENTS:
    implicit none

#include "finclude/petscsys.h"
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"

    integer , intent(in)  :: lbc, ubc                    ! column bounds
    integer , intent(in)  :: num_nolakec                 ! number of column non-lake points in column filter
    integer , intent(in)  :: filter_nolakec(ubc-lbc+1)   ! column filter for non-lake points
    integer , intent(in)  :: lbl, ubl                    ! landunit-index bounds
    integer , intent(in)  :: num_urbanl                  ! number of urban landunits in clump
    integer , intent(in)  :: filter_urbanl(ubl-lbl+1)    ! urban landunit filter

  ! !LOCAL VARIABLES:
    character(len=256) :: subname = 'Update_soil_temperature_clm_pf'
    integer  :: j,c,g                     !  indices
    integer  :: fc                        ! lake filtered column indices
    integer  :: gcount
    integer  :: begp, endp                ! per-proc beginning and ending pft indices
    integer  :: begc, endc                ! per-proc beginning and ending column indices
    integer  :: begl, endl                ! per-proc beginning and ending landunit indices
    integer  :: begg, endg                ! per-proc gridcell ending gridcell indices

    real(r8), pointer :: t_soisno(:,:)      ! soil temperature (Kelvin)
    integer , pointer :: cgridcell(:)       ! column's gridcell
    PetscScalar, pointer :: temp_clm_loc(:)  !
    PetscErrorCode :: ierr
  !EOP
  !-----------------------------------------------------------------------

    t_soisno       => ces%t_soisno
    cgridcell      => col%gridcell

    call get_proc_bounds(begg, endg, begl, endl, begc, endc, begp, endp)

    call VecGetArrayF90(clm_pf_idata%temp_clm, temp_clm_loc, ierr); CHKERRQ(ierr)

    do fc = 1,num_nolakec
       c = filter_nolakec(fc)
       g = cgridcell(c)
       gcount = g - begg
       do j = 1, nlevsoi
          t_soisno(c,j) = temp_clm_loc(gcount*nlevsoi+j)+273.15_r8
       enddo
       t_soisno(c,nlevsoi+1:nlevgrnd) = t_soisno(c,nlevsoi)
    enddo

    call VecRestoreArrayF90(clm_pf_idata%temp_clm, temp_clm_loc, ierr); CHKERRQ(ierr)
  end subroutine Update_soil_temperature_clm_pf

  !-----------------------------------------------------------------------------
  !BOP
  !
  ! !IROUTINE: update_drainage_clm_pf
  !
  ! !INTERFACE:
  subroutine update_drainage_clm_pf(lbc, ubc, &
       num_hydrologyc, filter_hydrologyc)

  !
  ! !DESCRIPTION:
  !
  !
  ! !USES:
    use shr_kind_mod  , only : r8 => shr_kind_r8
    use clmtype
    use clm_varctl    , only : iulog

    implicit none
    integer , intent(in) :: lbc, ubc                     ! column bounds
    integer , intent(in) :: num_hydrologyc               ! number of column soil points in column filter
    integer , intent(in) :: filter_hydrologyc(ubc-lbc+1) ! column filter for soil points

!
!EOP
!
! !OTHER LOCAL VARIABLES:
!
    character(len=256) :: subname = 'update_drainage_clm_pf'
    integer  :: c,fc                               ! indices
    real(r8), pointer :: qflx_drain_perched(:)     ! perched wt sub-surface runoff (mm H2O /s)
    real(r8), pointer :: qflx_drain(:)             ! sub-surface runoff (mm H2O /s)
    real(r8), pointer :: qflx_irrig(:)             ! irrigation flux (mm H2O /s)
    real(r8), pointer :: qflx_qrgwl(:)             ! qflx_surf at glaciers, wetlands, lakes (mm H2O /s)
    real(r8), pointer :: qflx_rsub_sat(:)          ! soil saturation excess [mm h2o/s]

    qflx_drain_perched    => cwf%qflx_drain_perched
    qflx_drain            => cwf%qflx_drain
    qflx_irrig            => cwf%qflx_irrig
    qflx_qrgwl            => cwf%qflx_qrgwl
    qflx_rsub_sat         => cwf%qflx_rsub_sat

    do fc = 1, num_hydrologyc
       c = filter_hydrologyc(fc)
       qflx_drain_perched(c) = 0._r8
       qflx_drain(c)         = 0._r8
       qflx_irrig(c)         = 0._r8
       qflx_qrgwl(c)         = 0._r8
       qflx_rsub_sat(c)      = 0._r8
    end do

    end subroutine update_drainage_clm_pf

#endif
end module clm_pflotran_interfaceMod

