module test_init_columns
  
  ! Tests of the dynInitColumns module

  use pfunit_mod
  use dynInitColumnsMod
  use clmtype
  use decompMod, only : bounds_type
  use clm_varcon, only : ispval, max_lunit
  use clm_varpar, only : nlevsno, nlevgrnd
  use shr_kind_mod, only : r8 => shr_kind_r8

  implicit none
  save

  logical, allocatable, private :: cactive_prior(:)
  type(bounds_type) :: bounds
  integer, parameter :: c_new = 32

contains

  subroutine setup()
    ! Set up variables needed for tests: various clmtype variables, along with
    ! bounds and cactive_prior.
    !
    ! col%active and cactive_prior need to be set by specific tests
    integer :: c, lev

    bounds%begg = 11
    bounds%endg = 13
    bounds%begl = 21
    bounds%endl = 29
    bounds%begc = 31
    bounds%endc = 49
    
    
    allocate(col%gridcell(bounds%begc:bounds%endc), source=9999)
    allocate(col%landunit(bounds%begc:bounds%endc), source=9999)
    allocate(col%active(bounds%begc:bounds%endc), source=.false.)
    allocate(cactive_prior(bounds%begc:bounds%endc), source=.false.)

    allocate(lun%coli(bounds%begl:bounds%endl), source=9999)
    allocate(lun%colf(bounds%begl:bounds%endl), source=9999)
    allocate(lun%itype(bounds%begl:bounds%endl), source=9999)

    allocate(grc%landunit_indices(max_lunit, bounds%begg:bounds%endg), source=9999)

    ! Note: we don't bother setting cols 40:49, because they're never referenced
    ! c index: 31 32 33 34 35 36 37 38 39
    ! l index: 22 22 22 22 23 23 23 21 21
    ! g index: 12 12 12 12 12 12 12 12 12
    ! ltype:   1  1  1  1  2  2  2  3  3

    col%gridcell(:) = 12
    col%landunit(31:39) = [22,22,22,22,23,23,23,21,21]
    lun%coli(21:23) = [38,31,35]
    lun%colf(21:23) = [39,34,37]
    lun%itype(21:23) = [3,1,2]
    grc%landunit_indices(1:3, 12) = [22,23,21]

    nlevgrnd=10
    allocate(ces%t_soisno(bounds%begc:bounds%endc, -nlevsno+1:nlevgrnd))
    do lev = -nlevsno+1, nlevgrnd
       do c = bounds%begc, bounds%endc
          ces%t_soisno(c, lev) = c*1000 + lev
       end do
    end do
  end subroutine setup

  subroutine cleanup()
    ! clean up stuff set up in setup()

    deallocate(col%gridcell)
    deallocate(col%landunit)
    deallocate(col%active)
    deallocate(cactive_prior)
    deallocate(lun%coli)
    deallocate(lun%colf)
    deallocate(lun%itype)
    deallocate(grc%landunit_indices)

    deallocate(ces%t_soisno)
    
  end subroutine cleanup

  ! ------------------------------------------------------------------------
  ! Tests of initial_template_col
  ! ------------------------------------------------------------------------

  @Test
  subroutine test_initial_template_no_landunit()
    ! no landunit of the given landunit_type on this grid cell
    call setup()
    cactive_prior(:) = .true.
    grc%landunit_indices(2,12) = ispval
    @assertEqual(ispval, initial_template_col(bounds, c_new, 2, cactive_prior))
    call cleanup()
  end subroutine test_initial_template_no_landunit

  @Test
  subroutine test_initial_template_no_active()
    ! no active columns on the given landunit_type
    integer :: template_col
    call setup()
    cactive_prior(:) = .true.
    cactive_prior(35:37) = .false.
    @assertEqual(ispval, initial_template_col(bounds, c_new, 2, cactive_prior))
    call cleanup()
  end subroutine test_initial_template_no_active

  @Test
  subroutine test_initial_template_all_active()
    ! all active columns on the given landunit type; should take the first
    call setup()
    cactive_prior(:) = .true.
    @assertEqual(35, initial_template_col(bounds, c_new, 2, cactive_prior))
    call cleanup()
  end subroutine test_initial_template_all_active

  @Test
  subroutine test_initial_template_second_active()
    ! first col on the given landunit is inactive, second is active; should take the
    ! second (ignoring the inactive column)
    call setup()
    cactive_prior(:) = .true.
    cactive_prior(35) = .false.
    @assertEqual(36, initial_template_col(bounds, c_new, 2, cactive_prior))
    call cleanup()
  end subroutine test_initial_template_second_active

  ! ------------------------------------------------------------------------
  ! Tests of initial_template_col_crop
  ! ------------------------------------------------------------------------

  @Test
  subroutine test_crop_active_in_soil_and_crop()
    ! there are active columns both on the soil & crop landunits; should take the soil one
    call setup()
    cactive_prior(:) = .true.
    @assertEqual(31, initial_template_col_crop(bounds, c_new, cactive_prior))
    call cleanup()
  end subroutine test_crop_active_in_soil_and_crop

  @Test
  subroutine test_crop_no_soil()
    ! no soil landunit, should take a crop column
    call setup()
    cactive_prior(:) = .true.
    grc%landunit_indices(1,12) = ispval
    @assertEqual(35, initial_template_col_crop(bounds, c_new, cactive_prior))
    call cleanup()
  end subroutine test_crop_no_soil

  @Test
  subroutine test_crop_no_soil_or_crop()
    ! no soil or crop landunits, should give ispval
    call setup()
    cactive_prior(:) = .true.
    grc%landunit_indices(1:2,12) = ispval
    @assertEqual(ispval, initial_template_col_crop(bounds, c_new, cactive_prior))
    call cleanup()
  end subroutine test_crop_no_soil_or_crop

  ! ------------------------------------------------------------------------
  ! Tests of initial_template_col_crop
  ! 
  ! Note that, although we don't have any explicit tests of copy_state, its behavior is
  ! implicitly tested through these tests
  ! ------------------------------------------------------------------------

  @Test
  subroutine test_initialize_new_columns_none()
    ! Nothing to initialize
    real(r8), allocatable :: t_soisno_expected(:,:)
    call setup()
    ! col%active and cactive_prior are a mix of true/true, false/false and false/true, so
    ! there's nothing to initialize
    col%active(:) = .true.
    cactive_prior(:) = .true.
    col%active(36) = .false.
    cactive_prior(36) = .false.
    col%active(37) = .false.
    t_soisno_expected = ces%t_soisno
    call initialize_new_columns(bounds, cactive_prior)
    @assertEqual(t_soisno_expected, ces%t_soisno)
    call cleanup()
  end subroutine test_initialize_new_columns_none

  @Test
  subroutine test_initialize_new_columns_ispval()
    ! Something to initialize, but template_col results in ispval: state should remain
    ! the same as before
    real(r8), allocatable :: t_soisno_expected(:,:)
    call setup()
    col%active(:) = .false.
    col%active(36) = .true.
    ! all cactive_prior points were false, so there's nothing to use as a template:
    cactive_prior(:) = .false.
    t_soisno_expected = ces%t_soisno
    call initialize_new_columns(bounds, cactive_prior)
    @assertEqual(t_soisno_expected, ces%t_soisno)
    call cleanup()
  end subroutine test_initialize_new_columns_ispval

  @Test
  subroutine test_initialize_new_columns_copy_state()
    ! Something to initialize, which results in a state copy
    real(r8), allocatable :: t_soisno_expected(:,:)
    call setup()
    col%active(:) = .false.
    col%active(36) = .true.
    cactive_prior(:) = .false.
    cactive_prior(32) = .true.
    t_soisno_expected = ces%t_soisno
    t_soisno_expected(36,:) = ces%t_soisno(32,:)
    call initialize_new_columns(bounds, cactive_prior)
    @assertEqual(t_soisno_expected, ces%t_soisno)
    call cleanup()
  end subroutine test_initialize_new_columns_copy_state

end module test_init_columns
